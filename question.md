# 一、 Java 基础

#### 1、hashMap的实现原理和底层结构，hashMap，get方法的时间复杂度
https://www.cnblogs.com/yangming1996/p/7997468.html
 >- HashMap 是 Map 的一个实现类，它代表的是一种键值对的数据存储形式。Key 不允许重复出现，Value 随意。jdk 8 之前，其内部是由数组+链表来实现的，而 jdk 8 对于链表长度超过 8 的链表将转储为红黑树。大致的数据存储形式如下：
 ![线程生命周期](images/hashmap.png)
 
    //默认的容量，即默认的数组长度 16
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
    //最大的容量，即数组可定义的最大长度 
    static final int MAXIMUM_CAPACITY = 1 << 30;
    
  >有关 HashMap 的基本属性大致介绍如上。下面我们看看它的几个重载的构造函数。
  
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
  
 >这是一个最基本的构造函数，需要调用方传入两个参数，initialCapacity 和 loadFactor。程序的大部分代码在判断传入参数的合法性，initialCapacity 小于零将抛出异常，大于 MAXIMUM_CAPACITY 将被限定为 MAXIMUM_CAPACITY。loadFactor 如果小于等于零或者非数字类型也会抛出异常。
 
#### 2、解决key哈希值冲突的方法
- 开放定址法
    >当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中:
    1. 线性探测法ThreadLocalMap:如果发生冲突，算法会简单的从该槽位置向后循环遍历hash表，直到找到表中的下一个空槽，并将该元素放入该槽中（会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用）。查找元素时，首先散列值所指向的槽，如果没有找到匹配，则继续从该槽遍历hash表，直到：（1）找到相应的元素；（2）找到一个空槽，指示查找的元素不存在，（所以不能随便删除元素）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的）
    2. 线性补偿探测法:即将上述算法中的线性探测的步长从 1 改为 Q ，在表的左右进行跳跃式探测，比较灵活。
 伪随机探测将线性探测的步长从常数改为随机数,这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚
- 链地址法
    >将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。（HashMap使用此法）
- 再哈希法
    >这种方法是同时构造多个不同的哈希函数，当发生哈希冲突时，就再计算一个哈希值，知道不冲突为止
- 建立公共溢出区
    >建立一个溢出区，凡是冲突的放到溢出区
#### 3、ArrayList与LinkedList的实现区别
#### 4、IO的几种模式（https://blog.csdn.net/woxinqidai/article/details/82717427）
        同步阻塞IO，同步非阻塞IO，IO多路复用，AIO(Asynchronous IO) 异步非阻塞IO
#### 5、说说反射机制的作用。
#### 6、反射机制会不会有性能问题？为什么
    
# 二、 Spring 基础

    1、spring事务的实现原理
    2、Spring框架中的单例bean是线程安全的吗?
    3、解释Spring框架中bean的生命周期。

# 三、 多线程

#### 1、volatile关键字的作用是什么
#### 2、Runnable接口和Callable接口的不同点？
#### 3、CyclicBarrier和CountDownLatch的区别
 ![线程生命周期](images/thread01.JPEG)
#### 4、volatile和synchronized的区别
   >- volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.
   >- volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.
   >- volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.
   >- volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.
#### 5、Lock和synchronized区别
    
#### 6、线程池ThreadPoolExecutor的工作原理
    （https://segmentfault.com/a/1190000012705130）
#### 7、新建T1、T2、T3三个线程，如何保证它们按顺序执行
#### 8、怎么中断一个线程？如何保证中断业务不影响？
#### 9、什么是重入锁？
#### 10、Fork/Join框架是干什么的？
#### 11、Jdk中排查多线程问题用什么命令？
#### 12、线程之间如何传递数据？
#### 13、FutureTask是什么？
#### 14、怎么唤醒一个阻塞的线程？
#### 15、什么是不可变对象，举例说明，在多线程有什么好处
       构造、测试和使用都很简单 
    　　线程安全且没有同步问题，不需要担心数据会被其它线程修改 
    　　当用作类的属性时不需要保护性拷贝 
    　　可以很好的用作Map键值和Set元素 
    　　不可变对象最大的缺点就是创建对象的开销，因为每一步操作都会产生一个新的对象。
#### 16、Java内存模型是什么，哪些区域是线程共享的，哪些是不共享的
#### 17、什么是乐观锁和悲观锁？
#### 18、什么是自旋锁？
#### 19、进程和线程的区别是什么？
    
    20、 如何确保N个线程可以访问N个资源同时又不导致死锁？
        
    
    

# 四、 jvm
    （http://www.importnew.com/23792.html）

    1、类加载机制，步骤，各做了什么事情
        （http://www.importnew.com/23742.html）
        
    2、jvm内存结构
         （http://www.importnew.com/23746.html）
        对象分配规则
        对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
        大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
        长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
        动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
        空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。
        
    3、GC算法 垃圾回收（http://www.importnew.com/23752.html）
    
        标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
        复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
        标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
        分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
        
        垃圾收集器
        
        
    4、GC分析 命令调优
        http://www.importnew.com/23761.html
        
    5、什么情况产生年轻代内存溢出、什么情况产生年老代内存溢出
    6、如何选择合适的垃圾收集算法？
    7、JVM中最大堆大小有没有限制？
    8、吞吐量优先选择什么垃圾回收器？响应时间优先呢？
    9、如何进行JVM调优？有哪些方法？
    10、如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？
    11、JDK和JRE的区别是什么？
        Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。
    


# 五、 算法


    1、使用代码写出快速排序
    2、使用代码写出堆排序
    3、倒排索引的原理
    4、谈一谈一致性哈希算法。

# 六、 分布式架构

    1、微服务如何实现幂等性
    2、分布式事务的实现方式有哪几种
    

# 七、 消息队列
### 1、activeMQ

### 2、rabiitMQ

### 3、kafka



# 八、 关系型数据库

### 1、 mysql
    
#### 1、mysql如何实现主从备份的
#### 2、Mysql中的myisam与innodb的区别

 >- InooDB支持事务，而MyISAM不支持事务
 >- InnoDB支持行级锁，而MyISAM支持表级锁
 >- InnoDB支持MVCC，而MyISAM不支持
 >- InnoDB支持外键，而MyISAM不支持
 >- InnoDB不支持全文索引，而MyISAM支持
        
#### 3、InooDB和MyISAM的select count（*）哪个更快，为什么
        
   >myisam更快，因为myisam内部维护了一个计算器，可以直接调取。MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。

#### 4、事务的4种隔离级别
        1）读未提交（read uncommitted）
        2）读已提交 (read committed)
        3）可重复读 (repeatable read)
        4）可串行化 (Serializable)
#### 5、一张表里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把mysql重启，再insert一条记录，这条记录的ID是18还是15 ？
   >- 如果类型是myisam，那么是18，MyISAM会把自增最大ID记录到数据文件里，重启最大id不会丢失
   >- 如果是innodb 那么是15，MyISAM会把自增最大ID记录到内存中，重启数据库或者OPTIMIZE操作都会导致最大ID丢失
#### 6、为什么使用数据索引能提高效率
        1）数据索引的存储是有序的
        2）在有序的情况下，通过索引查询一个数据是无需遍历索引记录的
        3）极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)
    7、B+树索引和哈希索引的区别（https://blog.csdn.net/weixin_42688876/article/details/81480311）
        B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且叶子节点的指针相互链接，是有序的
        哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从跟节点到叶子节点逐级查找，只需要 一次哈希算法即可，是无序的
        
    8、B树和B+树的区别（https://blog.csdn.net/weixin_42688876/article/details/81480311）
        B树，每个节点都存储key和data，所有的节点组成这可树，并且叶子节点指针为null，叶子节点不包含任何关键字信息
        B+树，所有的叶子节点中包含全部关键字的信息，及指向含有这些关键字记录的指针，且叶子节点本身依关键字的大小自小到大的顺序链接，所有的非终端节点可以看成是索引部分，节点中仅含有其子树根节点中最大（或最小）关键字
    
    9、什么情况下应不建或少建索引
        表记录太少
        经常插入、删除、修改的表
        数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。
        经常和主字段一块查询但主字段索引值比较多的表字段
    10、表分区有什么好处？
        分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。 2. 和单个磁盘或者文件系统相比，可以存储更多数据
        优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。
        分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。
        可与使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。
    11、分区表的限制因素
        1）、一个表最多只能有1024个分区
        2）、MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。
        3）、如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。
        4）、分区表中无法使用外键约束
        5）、MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。
    12、Mysql支持的分区类型有哪些？
        1）、RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区
        2）、List分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照list中的值分区，与RANGE的区别是，range分区的区间范围值是连续的
        3）、HASH分区：这种模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表
        4）、KEY分区：上面Hash模式的一种延伸，这里的Hash Key是Mysql系统产生的
    13、mysql的优化
        1）、开启查询缓存，优化查询
        2）、explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序
        3）、当只要一行数据时使用limit 1，Mysql数据库引擎会在找到一条数据后停止搜索，而不是继续往后查找下一条符合记录的数据
        4）、为搜索字段建索引
        5）、使用ENUM而不是VARCHAR，如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用ENUM而不是VARCHAR
        6）、Prepared Statement Prepared Statements很像存储过程，是一种运行在后台的sql语句集合，我们可以从使用prepared statement获得很多好处，无论是性能问题还是安全问题。Prepared Statements可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击
        7）、垂直分表
        8）、选择正确的存储引擎
    14、key和index的区别
        1）、key是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary key，unique key，foregin key等
        2）、index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等

# 九、 非关系型数据库

## redis 
    
    1、redis内存回收策略：
        （https://www.cnblogs.com/WJ5888/p/4371647.html）
      noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
      allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
      volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
      allkeys-random: 回收随机的键使得新添加的数据有空间存放。
      volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
      volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。
      
    2、redis键值最大的容量是多少？
    3、redis分片原理
    4、redis哈希剿的概念
    5、redis如何做内存优化
    6、redis插入大量数据的方法
        http://www.redis.cn/topics/mass-insert.html
    7、redis如何做横向扩容
    8、redis如何实现分布式锁，如何实现先到先得
    9、redis持久化的方式，各有什么优缺点
    10、海量日志如何排序和处理
    11、redis的key是如何寻址的
    
# 十、 笔试题
    
    
      




